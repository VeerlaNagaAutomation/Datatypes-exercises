# n = int(input('Enter the number'))
# num = n
# d = len(str(n))
# sum = 0
# while n!=0:
#     r = n%10
#     sum = sum + r**d
#     n = n//10
    
# if sum == num:
#     print('Armstrong Number')
# else:
#     print('Not A armstrong number')
    
#################################################   

# while True:
#     try:
#         num = int(input('Enter the integer number: '))
#         print('you entered',num)
#         break
#     except ValueError:
#         print("Invalid input please enter integer only")

######################################################
# import re
# s1 = "Python is easy and powerful"
# s2 = "Python is powerful and popular"

# words1 = set(re.findall(r'\b\w+\b',s1.lower()))
# words2 = set(re.findall(r'\b\w+\b',s2.lower()))

# common_words = words1 & words2

# print(common_words)

####################################################

# Q1 - Find the common words between STR1 and STR2
# STR1="Mirafra is a product engineering company located in Bangalore. Karnataka is an industrial state"
# STR2="Bangalore is in Karnataka. Mirafra has PAN India presence"

# s1=STR1.split()
# s2=STR2.split()

# common_words=[]

# for i in s1:
#     for j in s2:
#         if i == j and i not in common_words:
#             common_words.append(i)
# print(common_words)       ## ['Mirafra', 'is', 'in']     

##########################################################
# Q2 - Remove the duplicate words from the list and print the list.
# MyList=["Apple","Orange","Pineapple","Guava","Pears","Grapes","Apple","Pears"]

# l1=[ ]
# for i in MyList:
#     if i not in l1:
#         l1.append(i)
# print(l1)        

################################################

# Q3 - Find the 2nd largest element of the array without using a sorting.
# MyArr=[4,5,6,7,8,99,2,1,11,9,21,3,20]

# max_val = 0
# for i in MyArr:
#     if i > max_val:
#         max_val = i
# sec_max = 0
# for i in MyArr:
#     if i < max_val and i > sec_max:
#         sec_max = i
# print(max_val,sec_max) 


############################################################

# """ Q4 - Take position input from the user and using recursive function print Fibonacci series. Program shouldn't allow the user to input to enter any other value apart from integer. """

# def re_fib(n):
#     if n <= 1:
#         return n
#     return re_fib(n-1) + re_fib(n-2)
    
# pos = input('Enter position integer only: ')

# if pos.isdigit():
#     pos = int(pos)
#     for i in range(pos):
#         print(re_fib(i),end=' ')
# else:
#     print('Invalid input! pls enter the integer')
####################################################
data = """
Contact us at support@gmail.com or admin@company.in
Call 9876543210 or 9123456789
Backup email: test.user123@yahoo.com
"""
import re

def extract_emails_phones(text):
    # emails = re.findall(r'[a-zA-Z0-9.%_+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',text)
    # phones = re.findall(r'\b\d{10}\b',text)
    emails_phones = re.findall(r'[a-zA-Z0-9.%_+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}|\b\d{10}\b',text) 
    
    
    # return emails,phones
    return emails_phones
    
print(extract_emails_phones(data))   

##################################################

def is_valid(ip):
    
    match = re.fullmatch(r'\b((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)\b' ,ip)
    if match:
        print('Valid IP')
    else:
        print('Not a valid IP')
is_valid('10.145.88.90')    # Valid IP  

##################################################

check whether a given string contains all alphabets from A to Z (i.e., it is a pangram).

def is_pangram(s):
    s = s.lower()
    for ch in range(ord('a'), ord('z') + 1):
        if chr(ch) not in s:
            return False
    return True

text = input("Enter a string: ")
print("Pangram" if is_pangram(text) else "Not a Pangram")


#################################################


‚ùå Problem in Your Code
lst = [67, 89]

max_num = 0
sec_max = 0

for i in lst:
    if i > max_num:
        max_num = i
    if i < max_num and i > sec_max:
        sec_max = i

print(sec_max)

What goes wrong?

When i = 67

max_num = 67

second if fails (67 < 67 ‚ùå)

When i = 89

max_num = 89

second if fails (89 < 89 ‚ùå)

‚û°Ô∏è sec_max never updates, so output is 0 ‚ùå

‚úÖ Correct Logic (Single Pass ‚Äì Interview Friendly)
lst = [67, 89]

max_num = float('-inf')
sec_max = float('-inf')

for i in lst:
    if i > max_num:
        sec_max = max_num
        max_num = i
    elif i > sec_max and i != max_num:
        sec_max = i

print(sec_max)

‚úîÔ∏è Output
67

üß† Why This Works

When a new maximum is found:

Old max_num becomes sec_max

Handles:

Any order

Negative numbers

Duplicate values

‚úÖ Alternative (2-Pass Simple Logic)
lst = [67, 89]

max_num = max(lst)
sec_max = float('-inf')

for i in lst:
    if i != max_num and i > sec_max:
        sec_max = i

print(sec_max)

‚ö†Ô∏è Edge Case Handling (Must Mention in Interview)
if len(lst) < 2:
    print("Second max not possible")

üìù Interview Summary (One-Liner Explanation)

We track the maximum and second maximum in one traversal by shifting the old maximum to second maximum whenever a larger element is found.
################################


