How to print class name of class

class Test:
    pass

print(Test.__name__) # Test
#######
by useing object:
class Test:
    pass

obj = Test()
print(obj.__class__.__name__) # Test

__class__ gives the class of the object, and __name__ gives the class name.

############
âœ… 3. Using type() (Very common in interviews)
class Test:
    pass

obj = Test()
print(type(obj).__name__) #Test

#########################
x = 100
class Myclass:
    def __init__(self,value):
        self.value = value
        
    def show(self):
        global y
        y = x +1
        print(y)
        print(self.value)
        
O = Myclass(50)
O.show()
print(y)
op:
101
50
101
##############################
# same prog without global
x = 100
class Myclass:
    def __init__(self,value):
        self.value = value
        
    def show(self):
        y = x +1
        print(y)
        print(self.value)
        
O = Myclass(50)
O.show()
print(y)
op:
101
50
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 13, in <module>
NameError: name 'y' is not defined



##########################################################
âœ… 2ï¸âƒ£ Duck Typing (Very Simple)

ğŸ‘‰ Python cares about method, not class

class Dog:
    def sound(self):
        print("Bark")

class Cat:
    def sound(self):
        print("Meow")

def make_sound(animal):
    animal.sound()

make_sound(Dog())
make_sound(Cat())

âœ… Output
Bark
Meow

ğŸ§  One-line Explanation

If an object has the required method, Python uses itâ€”class type doesnâ€™t matter.



########################################################
âœ… Correct Way to Use super() (VERY IMPORTANT)
âœ” Call super() inside the overridden method
class Parent:
    def show(self):
        print("This is Parent")

class Child(Parent):
    def show(self):
        super().show()        # call parent method
        print("This is Child")

obj = Child()
obj.show()

âœ… Output
This is Parent
This is Child

ğŸ§  Simple Explanation (Interview Style)

super() is used inside a child class method to call the parent class implementation of the same method.

ğŸ”‘ Key Rules of super() (Memorize)

âŒ Cannot be used outside class

âœ… Must be inside a child method

âœ… Used to call parent method

âœ… Avoids hardcoding parent class name

âŒ Wrong vs âœ… Right (Quick Compare)

âŒ Wrong

super().show()


âœ… Right

def show(self):
    super().show()

ğŸ¯ One-Line Interview Answer

super() is used inside a child class method to access parent class methods and supports method overriding in polymorphism.


##########################
Below is a clear, simple, interview-ready explanation of super() with Multiple Inheritance and MRO (Method Resolution Order).
Iâ€™ll keep it easy, with small code and step-by-step logic.

ğŸ”¹ super() with Multiple Inheritance
ğŸ“Œ Why super() matters here

In multiple inheritance, more than one parent exists.
super() ensures:

Each class method is called once

Calls follow a well-defined order (MRO)

Avoids duplicate or skipped method calls

âœ… Basic Multiple Inheritance Example
class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        super().show()
        print("B")

class C(A):
    def show(self):
        super().show()
        print("C")

class D(B, C):
    def show(self):
        super().show()
        print("D")

obj = D()
obj.show()

âœ… Output
A
C
B
D


ğŸ‘€ Order looks surprising?
Thatâ€™s where MRO comes in.

ğŸ”¹ What is MRO (Method Resolution Order)?
ğŸ“Œ Definition (Interview Line)

MRO is the order in which Python searches for a method in a class hierarchy.
#########################
ğŸ”¹ Diamond Problem (Classic Interview Topic)
     A
    / \
   B   C
    \ /
     D


Without super() â†’ A may run twice
With super() â†’ A runs once âœ”ï¸

âœ… Correct Diamond Pattern
class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        super().show()
        print("B")

class C(A):
    def show(self):
        super().show()
        print("C")

class D(B, C):
    def show(self):
        super().show()
        print("D")

D().show()

ğŸ”‘ Rules to Remember (Interview Gold)

super() follows MRO

MRO is left-to-right, depth-first

Each method executes once

Always use super() in multiple inheritance

Use .mro() to debug issues

ğŸ¯ Perfect Interview Answer (Memorize)

In multiple inheritance, super() follows the Method Resolution Order (MRO) to ensure each parent method is called once. Python uses C3 linearization to determine this order, preventing duplicate calls and resolving the diamond problem.
#################################
âœ… Dunder Functions â€” Interview Definition (Simple & Crisp)

Dunder (double underscore) functions are special methods in Python that start and end with __ and are automatically invoked by Python to define or customize the behavior of objects with built-in operations like object creation, printing, comparison, and arithmetic.

# Dunder functions
# 4. __add__ â†’ Addition (+)
class Number:
    def __init__(self,x):
        self.x = x
    
    def __add__(self,other):
        return self.x + other.x
a = Number(10)
b = Number(20)
print(a+b)  # 30

class Number:
    def __init__(self, x):
        self.x = x
    def __mul__(self,other):
        return self.x * other.x
a = Number(10)
b = Number(20)
print(a*b) #200

class Number:
    def __init__(self, x):
        self.x = x
    def __sub__(self,other):
        return self.x - other.x
a = Number(10)
b = Number(20)
print(a-b) #-10


# 5ï¸âƒ£ __eq__ â†’ Equality (==)

class Test:
    def __init__(self,x):
        self.x = x
    def __eq__(self,other):
        return self.x == other.x
        
a = Test(5)
b = Test(5)

print(a==b) # True

6ï¸âƒ£ __lt__ â†’ Less than (<)

Used for comparisons.

class Test:
    def __init__(self, x):
        self.x = x

    def __lt__(self, other):
        return self.x < other.x

print(Test(3) < Test(5))


7ï¸âƒ£ __del__ â†’ Destructor

Called when object is deleted.

class Demo:
    def __del__(self):
        print("Object destroyed")

obj = Demo()
del obj


2ï¸âƒ£ __str__ â†’ String representation

Called when you use print(object).

class Person:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

p = Person("Ram")
print(p) #Ram
###############

#__str__ takes only ONE parameter â†’ self

#__str__ is used for string representation, not addition
class Person:
    def __init__(self, name):
        self.name = name

    def __add__(self, other):
        return self.name + " " + other.name

    def __str__(self):
        return self.name

p = Person("Ram")
q = Person("Setha")

print(p + q)

###################
ğŸ” Why __str__ is needed

Without __str__:

class Person:
    def __init__(self, name):
        self.name = name

p = Person("Ram")
print(p)

âŒ Output:
<__main__.Person object at 0x7f8c3b2d>


This is not human-readable.

âœ… With __str__
class Person:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

p = Person("Ram")
print(p)

âœ… Output:
Ram
#############


3ï¸âƒ£ __len__ â†’ Length

Called when len() is used.

class MyList:
    def __len__(self):
        return 5

obj = MyList()
print(len(obj)) #5

######################

# @satticmethod and @classmethod
# class Person:
#     name = 'Anonmyous'
#     @classmethod
#     def change_name(cls,name):
#         cls.name = name
        
# p1 = Person()
# p1.change_name('Ram')
# print(p1.name)
# print(Person.name)

class Employee:
    company = "Intel"

    @classmethod
    def change_company(cls, name):
        cls.company = name

Employee.change_company("NVIDIA")
print(Employee.company)

####################################
